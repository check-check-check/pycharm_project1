# @Time    : 
# @Author  : chen
# 模块的本质也是一个.py文件,模块能定义函数，类和变量，模块里也能包含可执行的代码。
"""
模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次
遇到导入import语句时才执行（import语句是可以在程序中的任意位置使用的,且针对同一个模块
很import多次,为了防止你重复导入，python的优化手段是：第一次导入后就将模块名加载到内存了，
后续的import语句仅是对已经加载大内存中的模块对象增加了一次引用，不会重新执行模块内的语句）
"""

"""
通常情况下，当使用 import 语句导入模块后，Python 会按照以下顺序查找指定的模块文件：
1.在当前目录，即当前执行的程序文件所在目录下查找；
2.到 PYTHONPATH（环境变量）下的每个目录中查找；
3.到 Python 默认的安装目录下查找。
"""
"""
以上所有涉及到的目录，都保存在标准模块 sys 的 sys.path 变量中，通过此变量我们可以看到
指定程序文件支持查找的所有目录。换句话说，如果要导入的模块没有存储在 sys.path 显示的目录中，
那么导入该模块并运行程序时，Python 解释器就会抛出 ModuleNotFoundError（未找到模块）异常。
"""
#%% 模块的导入，mode1模块在当前执行的程序文件所在目录下
import mode1
import mode1
import mode1
import mode1
import mode1
# 可以发现只打印了一次，是因为每次导入模块时，解释器都回去检查一下这个模块有没有之前被导过。
"""
模块导入的过程：
　　A.找到这个需导入的模块；
　　B.判断这个模块是否被导入过；
　　如果没有被导入过：创建一个属于这个模块的命名空间；如果用户没有定义变量来引用这个模块的内存地址的话，
那么就使用模块的名称来引用这个模块的内存地址；如果用户使用as来指定变量接受这个内存地址的话，那么就将内存地址
赋值给这个变量；且下文在调用时只能使用这个变量进行调用不能再使用模块名进行调用了。然后执行这个模块中的代码；
"""
'''
规范建议：模块应该一个一个的导入，先后顺序为：内置模块---->扩展（第三方）模块------>自定义模块；
顺序说明：我们知道导入模块其实就是在执行这个模块，我们不确定扩展模块或自定义模块里有没有某个功能
调用了内置模块，所以，我们在导入模块时，应先导入解释器内置的模块，然后在导入扩展模块，最后导入自定义模块。
'''
# 模块功能的调用
print(mode1.name)#调用变量
mode1.func1()#调用函数

#%%模块部分功能的导入
from mode1 import name
from mode1 import (func1, func2,func3)
print(name)
print('分隔符'.center(20,'*'))
func1()
print('分隔符'.center(20,'*'))
func2()
print('分隔符'.center(20,'*'))
func3()

"""我们在使用一个模块时可能只想使用其中的某些功能，比如只想使用sys模块中的modules时，那么import就不好用了，
这时我们可以使用from.....import这样的格式来进行模块的某个功能的导入。注意：这时模块是已经全部加载了，但只
是为这个功能进行了引用，其他的功能并没有引用，所以在使用模块的时候，就只能使用这个模块的这个功能，其他的功能
不能使用，如果想再使用这个模块的另一个功能时，可以在进行一次模块的要使用的功能的导入，这时模块不会再进行加载
了，而是只对该功能进行引用，这样我们就可以使用这个功能了。"""
#%% from.....import * 导入
"""* 表示导入模块中所有的不是以下划线(_)开头的名字都导入到当前位置，大部分情况下我们的python程序不应该使用这种
导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境
中导入时没有问题。"""
"""还有一点要说的是，如果使用* 的方式进行了导入，这时只想使用里面的某个或某些功能时，可以使用__all__来进行约束；"""
#在当前py中导入mod模块；
from mode1 import *
print(name)
func1()
func2()
func3()
#可以看到，所有的功能和名字都可以被调用；

